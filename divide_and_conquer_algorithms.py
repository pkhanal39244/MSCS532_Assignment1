# -*- coding: utf-8 -*-
"""Divide-and-Conquer Algorithms.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xjJHVtZEBKdoMNiCMCwzo0VKa0wV5MUe
"""

import random
import time
import sys

# Quick Sort Implementation
def quick_sort(arr):
    """
    Quick Sort Algorithm: Sorts an array by selecting a pivot element and
    partitioning the array into two sub-arrays, then recursively sorting the sub-arrays.
    """
    if len(arr) <= 1:  # Base case: an array with 1 or fewer elements is already sorted
        return arr

    # Randomly select a pivot element from the array
    pivot = arr[random.randint(0, len(arr) - 1)]

    # Partition the array into three parts: less than pivot, equal to pivot, and greater than pivot
    less_than_pivot = [x for x in arr if x < pivot]
    equal_to_pivot = [x for x in arr if x == pivot]
    greater_than_pivot = [x for x in arr if x > pivot]

    # Recursively apply Quick Sort to the sub-arrays
    return quick_sort(less_than_pivot) + equal_to_pivot + quick_sort(greater_than_pivot)


# Merge Sort Implementation
def merge_sort(arr):
    """
    Merge Sort Algorithm: Divides the array into two halves, recursively sorts each half,
    and then merges the two sorted halves.
    """
    if len(arr) <= 1:  # Base case: an array with 1 or fewer elements is already sorted
        return arr

    # Divide the array into two halves
    mid = len(arr) // 2
    left_half = merge_sort(arr[:mid])  # Recursively sort the left half
    right_half = merge_sort(arr[mid:])  # Recursively sort the right half

    # Merge the sorted halves
    return merge(left_half, right_half)


def merge(left, right):
    """
    Merge helper function: Merges two sorted sub-arrays into one sorted array.
    """
    merged = []
    i = j = 0

    # Compare elements from both arrays and append the smaller one to merged
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1

    # Append remaining elements from both arrays (if any)
    merged.extend(left[i:])
    merged.extend(right[j:])
    return merged


# Function to test both algorithms and measure execution time
def test_sorting_algorithms(arr):
    """
    Test and compare the performance of Quick Sort and Merge Sort on the provided array.
    """
    # Measure execution time for Quick Sort
    start_time = time.time()
    quick_sort_result = quick_sort(arr.copy())  # Use a copy to avoid in-place sorting modifying the original
    quick_sort_time = time.time() - start_time

    # Measure execution time for Merge Sort
    start_time = time.time()
    merge_sort_result = merge_sort(arr.copy())  # Use a copy for consistency
    merge_sort_time = time.time() - start_time

    # Return the sorted arrays and the execution times
    return quick_sort_result, merge_sort_result, quick_sort_time, merge_sort_time


# Main function to execute sorting algorithms on different datasets
def main():
    """
    Main function to generate random datasets, test the sorting algorithms, and compare their performance.
    """
    # Generate a random dataset of integers
    dataset_sizes = [1000, 5000, 10000, 20000]  # Varying sizes for testing
    results = []

    for size in dataset_sizes:
        print(f"\nTesting with dataset of size: {size}")

        # Generate a random dataset
        arr = [random.randint(0, 10000) for _ in range(size)]

        # Test both sorting algorithms and measure their execution times
        quick_sort_result, merge_sort_result, quick_sort_time, merge_sort_time = test_sorting_algorithms(arr)

        # Store results
        results.append((size, quick_sort_time, merge_sort_time))

        # Print the performance comparison
        print(f"Quick Sort Time: {quick_sort_time:.6f} seconds")
        print(f"Merge Sort Time: {merge_sort_time:.6f} seconds")

    # Print a summary of the results
    print("\nPerformance Comparison Summary:")
    print(f"{'Dataset Size':<15}{'Quick Sort Time (s)':<25}{'Merge Sort Time (s)'}")
    for size, quick_time, merge_time in results:
        print(f"{size:<15}{quick_time:<25}{merge_time}")

# Run the main function to start the analysis
if __name__ == "__main__":
    main()